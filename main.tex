%
% This document is available under the Creative Commons Attribution-ShareAlike
% License; additional terms may apply. See
%   * http://creativecommons.org/licenses/by-sa/3.0/
%   * http://creativecommons.org/licenses/by-sa/3.0/legalcode
%
% Copyright 2010 Jérôme Pouiller <jezz@sysmic.org>
%

% Pour faire une version imprimable, avec les notes sans overlay
% \PassOptionsToClass{notes=show,handout}{beamer}
% Pour en faire un article:
% \documentclass[10pt,ucs,usepdftitle=false,a4paper]{article}
% \usepackage{beamerarticle}

\documentclass[10pt,ucs,usepdftitle=false]{beamer}

% Pour mettre deux pages sur une
% (Préférer l'utilisation d'un post processing)
%\usepackage{pgfpages}
%\pgfpagesuselayout{2 on 1}[a4paper,border shrink=5mm]
%\pgfpagesuselayout{4 on 1}[a4paper,landscape, border shrink=5mm]
%\setbeameroption{show notes on second screen=right}

\input{style}

% Apparait sur chaque slide:
%\logo{\pgfimage[height=5mm]{pics/logo}}

\title{Systèmes d'exploitation}
\hypersetup{pdftitle={Temps Réel}}
% \subtitle{Sous-titre}
\author[Sysmic - J. Pouiller]{Jérôme Pouiller \email{j.pouiller@sysmic.org}}
\hypersetup{pdfauthor={Sysmic - Jérôme Pouiller}}
\institute[Sysmic]{}
%\institute[Sysmic]{\hspace*{1cm}\pgfimage[height=1.5cm]{pics/logo}}
% Plus complet:
% \institute[Sysmic]{
%   \inst{1} \hspace*{1cm}\includegraphics[height=1.5cm]{pics/logo}
%   \and
%   \inst{2} \includegraphics[height=1.5cm]{pics/logo-quiris}
% }
%\date[Juin 2012]{Juin 2012}
\date{}
% Pour le PDF seulement:
\subject{Systèmes d'exploitation}
\keywords{}
  
\begin{document}

  \begin{frame}[plain]
    \maketitle
    \note[item]{Parler de moi, de mon CV, freelance, sysmic, expertise, Polytech Paris, Tours, Insa Rennes}
  \end{frame}

  Objectif: Découvrir les systèmes d'exploitation en se basant sur Linux.
  Pedagogie: On apprend à utiliser Linxu et on généralise certaines connaissance.

  - Les Grandes classes d'OS moderne (== Posix?) -> Il faut juste expliquer ce qu'est Posix et y revenir plus tard -> 10min
     - Posix, embarqué ou non
     - Les non-Posix, embarqué ou non
     - Cygwin
     - Pourquoi Linux? 
       - Generique et generaliste : systeme embarqué -> suprcalculateur
       - Pedagogique car ouvert
       - Bonne application des standard -> Beaucoup d'autre OS n'ont qu'une sous ensemble de ses fonctionnalités
    - Liste d'OS -> nous y reviendrons lorsque nous aurons pris un peu de recul
      - Windows, Linux, VxWorks, MacOSX, Android, (cf chronologie), psos, ecos, rtos, ucosII, msdos, *BSD, SysV, 
  - Shell -> 2h
    - Historique: une des premier maniere de communique avec la machine (1970)
    - Plus ou moins normalisé, différentes implémentations, fonctionnent sur les *nix (Linux, android, iOS, OS compatibles Posix)
    - Obtenir un shell
    - Les différents shell (avec leurs historiques)
    - Lancer une commande
    - Les chemins
      - absolu
      - relatif
      - Le repertoire courants: pwd, cd
    - Séparation par des espaces
      - ARGC ARGV
    - Les options longues/courtes
      - getopts
    - Les commandes Posix
    - Les coreutils: ls, ls -l, cat, cat -e, cat -n, 
    - Le PATH
      - execve, ARGV[0]
    - Lancer une binaire locale
    - La commande ``file'', les type mimes, les extentions
    - Les variables:
       - Affectation, concatenation
       - variable locales
       - Vairable d'enviornnement
         - execvep (avec l'environement)
         - La commande env
         - Locale à une commande
       - Les variables d'environnements importantes
       - Les paramètres
       - Les sous-shell
       - Les expressions mathématiques $(()) ou $[]
    - Les redirection: 
       - e/s standards
       - Les file descriptor
       - > < | << EOF
    - Les différents fichiers de configuration
       - .Xshrc
       - /etc/*.conf
    - Les alias
    - Le globbing
      - Les deux exception: find et dpkg
    - ~ et les braces
    - Grep et les expression régulière
    - ed, sed, vi, emacs, vim, nano
    - awk, perl
    - Les scripts
      - Les sourcing
      - Les fonctions
    - Les jobs
      - fg/bg, etc...
    - La completion
      - La completion avancée
    - La documentation: man, Meta-H
    - Les bindings de touches:
       - VT102 -> Infernal
       - Meta-q, Ctrl+gauche, ....
    - Le réseau
      - /etc/resolv.conf
      - Les proxy DNS -> /run/nm...
      - route -n
      - ifconfig
      - iproute2
      - iptable/netfilter
    - Travailler à distance
      - telnet / tcpdump / arp floding
      - ssh
      - ssh-agent
      - ssh-askpass
      - Les tunnel
      - Les tunnel proxy
      - Les interface virtuelle
    - Les utilisateurs
       - root
       - Passer root
       - Les droits
       - chmod
       - Les groupes
       - les UID/GID, /etc/passwd /etc/group
       - Stickybit
       - SetUID -> /bin/ping
    - Un peu d'administration:
       - tar.gz/cpio / dpkg (-item -l -L -S) / rpm (-i -q) / ipk
       - apt-get / urpmi / yum
       - apt-cache, apt-get source, apt-get source -b, apt-get builddeps, etc...

  - L'arborescence -> 2h
    - Les différents fichiers: normaux, repertoire, liens, des filedevice characters, des filedevice block, des pipe, des socket nommées.
    - /usr/bin /bin /usr/sbin /sbin
      - Séparation /usr et /
      - Séparation bin et sbin
    - /lib* /usr/lib* -> Qu'est-ce qu'une bibliothèque?
    - /etc
    - /usr/share /usr/share/doc /usr/share/man
    - /var, /var/run, /run, /var/cache, /var/spool, /var/lib
    - /dev
      - filedevice: tout est fichier
      - /dev/sda -> octet du disque
        - commande dd permet de lire en specifiant des offset et des taille de lecture
      - /dev/sr0
      - /dev/ttyS0 -> port serie
      - pseudo device: /dev/null
      - /dev/random
      - /dev/zero
      - /dev/mem
      - /dev/psaux /dev/input/*
      - /dev/snd/
      - Plus pseciaux: /dev/rtc
      - Encore plus speciaux: /dev/video0, /dev/nvidia: nous y reviendrons lorsque nous travailloerons sur les drivers
      - N'apparaissent pas: 
        - Les bus (cas très rare et anormaux ou on fait des implementation en userland), 
        - Les cartes et les périphériques réseaux (à l'heure du cloud et des environnement distribué, ca peut avoir son importance)
      - Les carte video n'apparaissent pas toujours. Certains driver sont implémentés en userspace
      - Les filedecriptor
        - Sur des fichier
        - Autre appel système utilisant des filedescriptor
    - Les filesystems
      - point de montage
      - /mnt
      - mount
      - mount -o loop
      - /proc et /sys
      - Filesystems réseau: nfs, samba
      - Normallement implementé par le noyau, mais peut etre implemneté dans l'espace utilisateur avec fuse (/dev/fuse)
    - debootstrap
    - ./configure --prefix=
    - Au dela de la normalisation: /opt, /usr/local
    - Est-ce que l'on doit expliquer comment fonctionne les fichiers en interne:
       - vfat
       - ext2
    - Nom de fichiers authorisé sous *nix: tous les caractère sauf / et NUL
    - Systeme de fichier journalisé: en quoi ca consiste

  - La compilation
    - Makefile
      - target: deps
      - Regles implicites
      - Variables standards
      - Passer les varaible standard: par l'env, en arguments
      - Dépendance avec les .h
      - Avoir plusieurs configurations
    - Autotools
      - configure + Makefile, etc..
      - Compiler avec ces outils
      - Exemple d'utilisation de ./configure
      - Création d'un projet Autotools
    - Compatibilité avec les OS non Posix (fonctionne avec Cygwin)
      - Alternatives:
        - Cmake
    - Complexité et gestion des multiples options
      - Kmake
    - les fichiers generés par la compilation:
      - *.c *.h *.d *.o *.so ELF
    - Utilisation correcte des bibliothèques:
      - .so + .h
      - packet de dev vs packet de prod
    - ldconfig
    - libtools, LD_LIBRARY_PATH, LD_PRELOAD, 

    - linker: ld                             -> Il faut peut-être faire l'architecture de la mémoire avant -> Et avant la memoire, il faut voir les process
    - A-t-on le droit de se linker avec la biliotheque: parlon sdes licences
      - GPL, etc...
  - Les tâches
    - monotache
    - Les interruptions
      - Les PICs
      - Le multiplexing d'interruption
    - Foregrund/Background
    - Le temps partagé = concurrence != parallèle
    - Le multitache non-préemptif
      - Le context-switching
    - Le multitache préemptif -> HZ, dynamic HZ
    - La gestion de la mémoire en multitâche
      - La MMU
      - Addresse virtuelle/ Addresse phyique
      - Le segfault
      - L'allocation -> sbrk ou mmap
      - Le passage usermode -> kernelmode
      - les appels système
         - Dans le noyau
         - Dans la libc
         - Le swap sw contexte, la problèmatique des accès concurrant
      - mmap
      - Le cache
      - Copy On Write
      - Le swap, la swapiness
      - La compression de la mémoire
      - Le merging de page
      - La gestion du cache d'instruction et du cache de donnée
      - Le TLB
  - La gestion de la mémoire
     - En user space
       - L'allogrithme de malloc
       - D'autres algorithme
       - Les technique de debug
         - libefence
         - DUMA
         - Valgrind
     - En kernelspace
       - kmalloc, vmalloc, la memoire haute, 
       - Le mapping mémoire du noyau
       - Le SLAB
       - memcheck
       - mem(l'autre que memcheck)
     - Allocation mémoire et predictabilité
  - Format des fichiers ELF -> A faire après la memoire
    - Script de link (c'est la suite de la compilation, mais apres avoir compris le fonctionnement de la MMU)
    - Format d'appel des fonctions
    - resolution dynamique des symboles, LD_PRELOAD, LD_LIBRARY_PATH
    - sections
    - les symboles  -> objdump
    - les symboles/sections de debug -> objcopy, strip
    - Comment fonctionne un debuggeur? -> gdb 
      - Coredump
      - host/target
    - Comment fonctionne une sonde JTAG? -> openocd
    - Les probe
    - La couverture de code
    - gperf
    - perf/oprofile
    - dynamic printk
    - strace/ltrace
    - Les autres outils pour le dev système
       - diff /patch
       - patchutils
       - quilt
       - svn
       - git -> github
       - L'intégration continue
       - Le codingstyle du noyau
         - astyle, indent, utilisez un vrai editeur
       - La revue de code
       - Les certifications
  - La communication interprocessus
    - La communication inter thread
      - Problematique:
        - Memoire partagée
        - Pariphérique partagée
      - Les buffers ciculaires
      - Les mutex
      - Les semaphore
      - Les rendez-vous
      - Les spin-lock
      - Les condition
      - Les RCU et autres algo sioux
    - Les signaux
      - les signaux temps réel
    - Les SHM -> /!\ Alllocation
    - Les mq
    - Les sem
      -> Et tout ca, c'est tout pourris
      -> Allez vois Xenomai
  - Les drivers;
    - en monotache -> = une bibliothèque, avec eventuellement, une gestion d'interruption (msdos)
    - en multitache -> gere les accès conurrent
    - Les drivers sous Linux: des char device
    - Les major et les minor
    - copytouser, copy fromuser
    - Compiler les driver, dans le kernel, a l'exterieur du kernel
    - on revient sur le filedescriptor
    - Mapper des registres en mémoire
      - POssible en espace utilisateur avec mmap sur /dev/mem
      - C'est la raison pour laquelle, il n'y a pas de device pour les carte graphique
    - Allouer une interruption, return IRQ_HANDLED et multiplexage
      -> Soft IRQ
      [Reprendre la parte du cours ``L'API'', wait queue, etc...]
    - Les DMA
      - Comment ca marche
    - Fonctionnement d'une STB sans copie de mémoire
    - Debug des drivers
      - kgdb
      - etc...
  - Les API et les archtectures d'OS
    - système de linux:
       - inotify
       - timerfd
       - signalfd
       - Gestion des utilisateurs
       - Gestion de l'heure
       - Gestion des fichier
       - Gestion de file descriptor et gestion du réseau: ~ read/write, mais spécialiste dans le réseau -> ca reste des file descriptor
     - système sous Windows
       - 
     - Sous Hurd 
  - La virtualisation
     - Plusieurs type
        - Complete
        - Noyau seulement
        - Hyperviseur
     - L'interpretation
     - La JIT
        - Tehcnique provenant du bytecode
     - L'acceraltion matérielle du MMU
     - Architecture de Virtual Box
     - Architecture de VMWar hypervisor
  - Le boot
     - La ROM
     - La flash
     - Les bootloader: bios, grub, isolinux, uboot, etc..
     - Le noyau, eXecute In Place, la decompression
     - Apres le boot du noyau
       - SysV
       - upstart 
       - runit
       - systemd
     - Le boot par réseau
     - Le boot NFS
     - Le plugnplay, Le format DTS/openfirmware
     

  - Travailler en embarqué
    - La cross compilation
      - Le host/la target
      - Avec Make
      - Avec Autotools
    - Busybox
    - Compiler la tool chain
      - Yann
    - Compiler le noyau
      [plein de choses à dire]
    - Créer le filesystem. 
      - JFFS2
    - Le recopier sur la flash 
    - Monter en local l'image JFFS2
    - Buildroot
    - Qemu + scratchbox
    - 

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
